import java.nio.file.Files
import java.nio.file.Paths
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.util.concurrent.TimeUnit
import java.util.stream.Collectors
import java.util.stream.Stream

buildscript {
    repositories {
        mavenCentral()
    }
}
plugins {
    id("com.kotori316.common")
    id("com.kotori316.jars")
    id("com.kotori316.publishments")
    id("maven-publish")
    id("signing")
    id("scala")
    id("net.neoforged.gradle.userdev") version("7.+")
    // id("org.parchmentmc.librarian.forgegradle") version("1.+")
    id("com.github.breadmoirai.github-release") version("2.4.1")
    id("com.matthewprenger.cursegradle") version("1.4.0")
    id("com.modrinth.minotaur").version("2.+")
    id("com.kotori316.plugin.cf").version("1.6")
}
// Only edit below this line, the above code adds and enables the necessary things for Forge to be setup.

compileScala {
    scalaCompileOptions.additionalParameters = ["-Wconf:cat=deprecation:w,any:e"]
}

@SuppressWarnings("SpellCheckingInspection")
private static boolean isInCI() {
    return Boolean.parseBoolean(System.getenv("GITHUB_ACTIONS")) || Boolean.parseBoolean(System.getenv("CI")) ||
            (!System.getProperty("os.name").toLowerCase().startsWith("windows") && Files.exists(Paths.get("/", ".dockerenv")))
}

runs {
    configureEach {
        systemProperties.put("forge.logging.markers", "")
        systemProperties.put("mixin.env.remapRefMap", "true")
        systemProperties.put("mixin.env.refMapRemappingFile", "${projectDir}/build/createSrgToMcp/output.srg")
        systemProperties.put("mixin.debug.export", "true")
        systemProperties.put("forge.logging.console.level", "debug")
    }

    client {
        workingDirectory.set(project.file("Minecraft"))
        systemProperties.put("forge.enabledGameTestNamespaces", "QuarryPlus".toLowerCase())
        // Your access token, you can find it in your ".minecraft/launcher_profiles.json" file
        // If not set, use "0" to prevent authentication exception.
        programArguments.addAll("--accessToken", (project.findProperty("mc_token") ?: "0") as String)
        jvmArguments.add("-EnableAssertions".toLowerCase())

        modSources.add(project.sourceSets.main)
    }

    /*client2 {
        parent(runs.client)
        workingDirectory project.file("run-server-client")
        systemProperties.put("forge.enabledGameTestNamespaces", "")
        systemProperties.put("forge.enableGameTest", "false")
        modSources.add(project.sourceSets.main)
    }*/

    server {
        workingDirectory.set(project.file("run-server"))

        // Recommended logging data for a userdev environment
        programArguments.add("--nogui")

        modSources.add(project.sourceSets.main)
    }

    data {
        workingDirectory.set(project.file("run-server"))
        programArguments.addAll("--mod", "quarryplus", "--all", "--output", file("src/generated/resources/").toString(), "--existing", file("src/main/resources/").toString())

        modSources.add(project.sourceSets.main)
        modSources.add(project.sourceSets.test)
    }

    gameTestServer {
        workingDirectory.set(project.file("game-test"))
        systemProperties.put("forge.enabledGameTestNamespaces", "QuarryPlus".toLowerCase())
        jvmArguments.add("-EnableAssertions".toLowerCase())

        modSources.add(project.sourceSets.main)
        modSources.add(project.sourceSets.test)
    }
}

configurations {
    game_test
}

dependencies {
    String forgeVersion = System.getenv("CI_FORGE") ?: project.forgeVersion
    implementation(group: "net.neoforged", name: "neoforge", version: forgeVersion)
    compileOnly(group: "org.scala-lang", name: "scala-library", version: project.scalaVersion)
    // compileOnly(group: "org.scala-lang", name: "scala3-library_3", version: project.scala3Version)
    compileOnly(group: "org.typelevel", name: "cats-core_3", version: project.catsVersion) {
        exclude(group: 'org.scala-lang', module: 'scala3-library_3')
    }
    testImplementation(group: "org.scala-lang", name: "scala-library", version: project.scalaVersion)
    // testImplementation(group: "org.scala-lang", name: "scala3-library_3", version: project.scala3Version)
    testImplementation(group: "org.typelevel", name: "cats-core_3", version: project.catsVersion) {
        exclude(group: 'org.scala-lang', module: 'scala3-library_3')
    }

    compileOnly(group: "mezz.jei", name: "jei-1.20.2-common-api", version: project.jeiVersion)
    compileOnly(group: "mezz.jei", name: "jei-1.20.2-forge-api", version: project.jeiVersion)
    compileOnly(group: "me.shedaniel", name: "RoughlyEnoughItems-neoforge", version: project.reiVersion)
    // runtimeOnly(group: "me.shedaniel.cloth", name: "cloth-config-neoforge", version: project.clothVersion)
    // runtimeOnly(group: "dev.architectury", name: "architectury-neoforge", version: project.architecturyVersion)

    runtimeOnly(group: "com.kotori316", name: "ScalableCatsForce-NeoForge".toLowerCase(), version: project.slpVersion, classifier: "with-library") {
        transitive(false)
    }

    boolean enableFTB = false // Boolean.parseBoolean(System.getenv("USE_FTB"))
    if (enableFTB) { // FTB Chunks stuff
        implementation(group: "dev.ftb.mods", name: "ftb-chunks-forge", version: project.ftbChunksVersion)
        implementation(group: "dev.ftb.mods", name: "ftb-library-forge", version: project.ftbLibraryVersion)
        runtimeOnly(group: "dev.ftb.mods", name: "ftb-teams-forge", version: project.ftbTeamsVersion)
        implementation(group: "dev.architectury", name: "architectury-neoforge", version: project.architecturyVersion)
    } else {
        compileOnly(group: "dev.ftb.mods", name: "ftb-chunks-forge", version: project.ftbChunksVersion) {
            transitive(false)
        }
        compileOnly(group: "dev.ftb.mods", name: "ftb-library-forge", version: project.ftbLibraryVersion) {
            transitive(false)
        }
    }

    // IC2 Classic
    if (false) {
        // if (System.getenv("IGNORE_OTHER_MODS_IN_RUNTIME") == null) {
        compileOnly(group: "curse.maven", name: "ic2-classic-242942", version: project.ic2ClassicId)
        testImplementation(group: "curse.maven", name: "ic2-classic-242942", version: project.ic2ClassicId)
    } else {
        compileOnly(group: "curse.maven", name: "ic2-classic-242942", version: project.ic2ClassicId)
        // testCompileOnly(group: "curse.maven", name: "ic2-classic-242942", version: project.ic2ClassicId)
    }

    // Test Dependencies.
    // Required these libraries to execute the tests.
    // The library will avoid errors of ForgeRegistry and Capability.
    implementation(group: "com.kotori316", name: "test_utility_neo", version: project.testUtilVersion)
    implementation(group: "com.kotori316", name: "test_utility_dependency", version: "2.0-SNAPSHOT") {
        exclude(group: 'org.scala-lang', module: 'scala3-library_3')
    }

    game_test(group: "org.junit.jupiter", name: "junit-jupiter-api", version: project.jupiterVersion)
    game_test(group: "org.junit.jupiter", name: "junit-jupiter-params", version: project.jupiterVersion)
    game_test(group: "org.junit.jupiter", name: "junit-jupiter-engine", version: project.jupiterVersion)
    game_test(group: "org.junit.platform", name: "junit-platform-launcher", version: project.jupiterPlatformVersion)
}

tasks.named("jar", org.gradle.jvm.tasks.Jar).configure {
    finalizedBy("jksSignJar")
}

tasks.register("jksSignJar", com.kotori316.common.JarSignTask.class) {
    dependsOn(project.tasks.jar)
    jarTask = (project.tasks.jar as org.gradle.jvm.tasks.Jar)
}

def changeLogHeader() {
    return ("""\
            For Minecraft ${project.minecraftVersion} and NeoForge.
            Released at ${ZonedDateTime.now(ZoneId.of("Asia/Tokyo")).withNano(0).format(DateTimeFormatter.ISO_OFFSET_DATE_TIME)}

            This mod requires [Scalable Cat's Force](https://www.curseforge.com/minecraft/mc-mods/scalable-cats-force)
            Build with ${project.forgeVersion}, Mapping: parchment ${project.parchmentMapping + "-" + project.minecraftVersion}
            """ as String).stripIndent()
}

def combinedLog() {
    def header = changeLogHeader() + System.lineSeparator() * 2
    def file = new File("temp_changelog.md")
    def fileText = file.exists() ? file.text : "No changelog provided."
    return header + fileText
}

static String getCommit(String branch) {
    try {
        ProcessBuilder builder = new ProcessBuilder("git", "rev-parse", branch)
        def process = builder.start()
        process.waitFor(1L, TimeUnit.SECONDS)
        try (def stream = new InputStreamReader(process.getInputStream())
             def reader = new BufferedReader(stream)) {
            def commit = reader.readLine()
            return commit ?: ""
        }
    } catch (IOException ignored) {
        if (!isInCI())
            println("Caught $ignored")
        return ""
    }
}

String getChangeLog() {
    return changeLogHeader() + System.lineSeparator() + getShortChangelog(true)
}

String getShortChangelog(boolean includeVersion) {
    def f = file("temp_changelog.md")
    if (f.exists()) {
        String version = f.readLines().find { s -> s.startsWith("#") }
        def content = f.readLines()
                .drop(4 - 2)
                .takeWhile { s -> !s.isEmpty() }
                .stream() as Stream<String>
        if (includeVersion) {
            return Stream.concat(
                    Stream.of(version, ""),
                    content
            ).collect(Collectors.joining(System.lineSeparator()))
        } else {
            content.collect(Collectors.joining(System.lineSeparator()))
        }

    } else {
        return version.toString()
    }
}

githubRelease {
    repo.set("QuarryPlus")
    token = project.findProperty("githubToken") ?: System.getenv("REPO_TOKEN") ?: ""
    targetCommitish.set(project.branch as String)
    prerelease.set(project.version.toString().contains("SNAPSHOT"))
    body.set(getChangeLog())
    releaseAssets = files(
            jar,
            deobfJar,
            sourcesJar,
    )
}

tasks.register("checkCompileOption") {
    setDescription("Verify the compile option.")
    doLast {
        System.out.println("Changelog for GitHub")
        System.out.println("-" * 30 as String)
        System.out.println(getChangeLog())
        System.out.println("-" * 30 as String)
        System.out.println("Git commit")
        System.out.println(getCommit(project.branch as String))
        System.out.println("-" * 30 as String)
        System.out.println(getShortChangelog(false))
    }
}

tasks.register("copyToDrive", Copy) {
    dependsOn("build")
    description = "Copy jar files to directory specified in environmental value of `drive_path`"
    def PATH_NAME = "drive_path"
    from(jar.getArchiveFile(), deobfJar.getArchiveFile(), sourcesJar.getArchiveFile())
    into(file(java.util.Optional.ofNullable(System.getenv(PATH_NAME)).orElse(".")))
    onlyIf {
        System.getenv(PATH_NAME) != null &&
                Files.exists(Paths.get(System.getenv(PATH_NAME)))
    }
}
